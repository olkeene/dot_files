nil
ReferralTracker.find(2).ref_data
reload!
class ReferralTrackerAddRefDataId < ActiveRecord::Migration
  def self.up
    add_column :ref_datas, :ref_data_id, :integer
  end
  def self.down
    remove_column :referral_trackers, :ref_data_id
end
    add_column :ref_datas, :referral_tracker_id, :integer
ReferralTrackerAddRefDataId.down
    remove_column :ref_datas, :referral_tracker_id
ReferralTrackerAddRefDataId.up
def self.down
    add_column :referral_trackers, :ref_data_id, :integer
ReferralTracker.find(2).ref_data_by_id
ReferralTracker.find(2).ref_data_by_id.find
ReferralTracker.find(2)
RefData.first
RefData.first.referral_trackers_by_id
exit
User.last
User.last.refs_can_use_pp_email? 'p@.com'
User.last.refs_can_use_pp_email? 'p@p.com'
[true, 100.years.ago]
[[true, 100.years.ago]]
{}[[true, 100.years.ago]]
{[] => nil}[[true, 100.years.ago]]
{}[[true, 100]]
{[true, 100.years.ago] => ')'}
{}[[true, 100.years.ago].freeze]
'ICS' == 'ICS'
ref_data = RefData.last
ref_data.referral_trackers.create!(:ref_name => ref_nam :ref_web_site =>'ics')
ref_data.referral_trackers.create!(:ref_name => 'some', :ref_web_site =>'ics')
User.last.account
User.last.account.ref_bonus_add(15)
class AssignMissedRefDataToRt < ActiveRecord::Migration
    ReferralTracker.all.each do |rt|
      next unless rt.ref_data_id.blank? # association ok
      if rd = RefData.find_by_ref_name(rt.ref_name)
        rt.ref_data = rd
      end
    end
AssignMissedRefDataToRt.up
ReferralTracker.all.each do |rt|
p rt.ref_name
        p '-----'
        rt.save!
User.last.paid_survey_qualified?
User.last.authorized?
User.last.reg_drawing_out
User.last.game_session.total_surveys_answered
User.last.can_be_a_pro_user?
%W/post put delete get head/.each do |m|
    define_method "#{m}?" do
      request_method == m.to_sym
%W/post put delete get head/
ViddlerGateWay.get_record_token
ViddlerGateWay
app.post
app.post 'http://localhost:3000/pro_accounts/web_cam_record_create'
app.post 'http://localhost:3000/pro_accounts/web_cam_record_create', {"record_token"=>"18a52f31280bc4119a4c455641534841149", "user_video_number"=>"98", "video_id"=>"803a4a25", "authenticity_token"=>"2zAIGrVOS7uwEpSiTZYPqxTYcMR3QepHqbUcA6Dl0c8=", "user_name"=>"levasha"}
Jobs::VideoAssetJobs
Jobs::VideoAssetJobs.process_videos_in_queue
VideoAsset
VideoAsset.last
VideoAsset.last.save!
VideoAsset.last.touch
VideoAsset.last.touch!
VideoAsset.last.update_attribute :created_at, Time.now
VideoAsset.last.ready_to_use?
VideoAsset.last.duration
VideoAsset.last.s
VideoAsset[0]
VideoAsset.first
VideoAsset.first.trait
ProAccount.first.trait
ProAccount.first
Trait.last
Trait.last.user
CustomerMailer.deliver_pro_user_become_pro(User.last)
Trait.last.pro_account.video_assets.first.ready_to_use!
Trait.last.user.pro_account.video_assets.first.ready_to_use!
VideoAsset.first.available?
VideoAssetJobs.transfer_and_encode_file VideoAsset.last
Jobs::VideoAssetJobs.transfer_and_encode_file VideoAsset.last
ProAccount
ProAccount.last
ProAccount.last.videos
Rake
require 'rake'
Rake.task
Rake.new('db:migrate').invoke
Rake::Task('db:migrate').invoke
Rake::Task['db:migrate'].invoke
Rake::Task['db:migrate'].execute
class VideoPool < ActiveRecord::Migration
    create_table :video_pools do |t|
      t.integer  :record_id, :null => false
      t.datetime :created_at
    add_index :video_pools, :record_id_id
    drop_table :video_pools
VideoPool.down
      t.integer  :videoable_id, :null => false
    add_index :video_pools, :videoable_id
 VideoPool.up
ProAccount.last.videos.build
ProAccount.last.videos.build.videoable
reload1
Jobs::VideoAssetJobs.asynch_video_processing VideoAsset.last
Jobs::VideoAssetJobs.asynch_video_processing VideoAsset.last.id
VideoAsset.last.id
VideoPool
VideoPool.available?
VideoAsset.unprocessed
VideoAsset.last.update_attribute :step, VideoAsset:StepEncoding
VideoAsset.last.update_attribute :step, VideoAsset::StepEncoding
caller
caller.join "\n"
Jobs::VideoAssetJobs.asynch_video_processing WebCamVideoAsset.last
WebCamVideoAsset.last.class
WebCamVideoAsset.last.class_name
WebCamVideoAsset.last.classname
WebCamVideoAsset.last.to_class
WebCamVideoAsset.last.name
WebCamVideoAsset.last.class.name
'VideoAsset'.constantize
User.last.pro_user?
Proaccount.last.pro_user?
ProAccount.last.pro_user?
ProAccount.last.trait.pro_user?
User.last.joined_pro?
WebCamVideoAsset
WebCamVideoAsset.first
WebCamVideoAsset.first.pro_account.videos.first
WebCamVideoAsset.first.pro_account.videos.count > 1
WebCamVideoAsset.first.send :destroy_prev_record
User.last.should_record_welcome?
User.last.pro_account.should_record_welcome?
User.last.pro_account.videos.unprocessed.exists?
User.last.pro_account.videos.ready_to_use.approved.exists?
User.last.pro_account.videos.ready_to_use.exists?
User.last.pro_account.videos.exists?
User.last.pro_account.videos.process_video
User.last.pro_account.videos.first.process_video
User.last.pro_account.videos.first.send :process_video
User.last.pro_account.welcome_video
User.last.cash_transactions.exists?(["prize_type = ?", CashTransaction::VIDEO_BONUS_WELCOME])
WebCamVideoAsset::VideoMaxLength
User.last.add_cash(ProAccount::WELCOME_VIDEO_PRIZE_AMOUNT, false, :prize_type => CashTransaction::VIDEO_BONUS_WELCOME)
VideoAsset.unprocessed[0]
VideoAsset.first.videoable
VideoAsset.first.videoable.videos.class
VideoAsset.first.videoable.videos[0].class
VideoAsset.first.videoable.videos[0].class.name
VideoAsset.first.videoable.videos[10].class.name
VideoAsset.empty_trash
VideoAsset.first.move_to_trash
ProAccount.first.videos
Survey.last.videos
VideoAsset.county
VideoAsset.county 'a'
require 'factory_girl'
Factory.create(:user_with_pro_account)
# We need to create unique email addresses for each person
Factory.sequence(:email) { |n| "person#{n}@example.com" }
# User -> parent_user -> child
# alias :user_grand_parent
Factory.define :user, :class => User do |f|
  f.email              { Factory.next :email}
  f.email_confirmation { |u| u.email }
  f.user_type         'user'
  f.banned            0
  f.password          '123456'
  f.password_confirmation  '123456'
  f.usa_resident     "1"
  f.terms_of_service  "1"
  f.years_18_old      "1" 
Factory.define :child_with_parent, :parent => :user do |f|
   f.association :parent, :factory => :user
Factory.define :user_with_pro_account, :parent => :user do |f|
   f.association :pro_account, :factory => :pro_account
Factory.define :pro_account do |f|
   f.pro_account {|a| a.association(:pro_account) }
Factory(:user_with_pro_account)
Factory(:user_with_trait)
Factory.define :user_with_trait, :parent => :user do |f|
   f.activated 1
   f.first_name 'Robert'
   f.last_name  'H'
   f.association :trait, :factory => :trait
Dir['test/factory']
Dir['test/factory/*']
Dir['test/factories/*']
Dir['test/factories/*'].each
Dir['test/factories/*'].each{|f| require f}
Factory[:child_with_parent]
Factory(:child_with_parent)
m = CustomerMailer.deliver_welcome_message User.last
m = CustomerMailer.deliver_welcome_message User.find(3054)
VideoAssetJobs.transfer_and_encode_file(21357)
Survey.find(21357).video
Survey.find(21357).video.clone_and_attache_to Survey.find(1230)
g = SurveyFakeAnswersGenerator.new Survey.find(1230)
g = Generators::SurveyFakeAnswersGenerator.new Survey.find(1230)
g.generate 10
Survey.find(1230).target_market.respondents
g.generate 60
Survey.find(1230).completed_surveys.stats.count
g = Generators::SurveyFakeAnswersGenerator.new Survey.find(21357)
Account.last
Account.last.user
User.first
User.find(2)
User.find(3054).account
User.find(3054).account.send :first_coins_notification
Account.count
User.find(3054).account.first_coins_notification
User.find(3054).account.class
User.find(3054).account.size
User.find(3054).account.orders.size
User.find(3054).account.orders.count
Account.find(982).orders.count
Account.find(982).orders.size
Order.find(154).first_coins_notification
Order.find(154).send :first_coins_notification
Order.find(154).send :send_notification
Order.find(154).send :send_notifications
kmnklmeload!
Order.find(154).account.user
Order.find(154).account.user.notifications
Time.now
Time.now +6.hours
Time.now + 6.hours
UserNotification.first
UserNotification.first.deliver!
UserNotification.first.user
User.find(3054).surveys.with_statuses(Survey::STATUS_STARTED, Survey::STATUS_FINISHED).exists?
User.find(3054).
User.ind(3054)..surveys.with_statuses([Survey::STATUS_STARTED, Survey::STATUS_FINISHED]).exists?
User.find(3054).surveys.with_statuses([Survey::STATUS_STARTED, Survey::STATUS_FINISHED]).exists?
class UsersAddRunAnySurvey < ActiveRecord::Migration
    add_column :users, :run_any_survey, :boolean, :default => 0
    User.all.each do |u|
      u.update_attribute :run_any_survey, true if u.surveys.with_statuses([Survey::STATUS_STARTED, Survey::STATUS_FINISHED]).exists?
    add_index :users, [:run_any_survey, :last_seen_at]
    remove_column :users, :run_any_survey
UsersAddRunAnySurvey.up
User.all.each do |u|
User.find(3054.surveys.with_statuses([Survey::STATUS_STARTED, Survey::STATUS_FINISHED]).exists?)
User.find)(3054.surveys.with_statuses([Survey::STATUS_STARTED, Survey::STATUS_FINISHED]).exists?)
#      u.update_attribute :run_any_survey, true if u.surveys.with_statuses([Survey::STATUS_STARTED, Survey::STATUS_FINISHED]).exists?
      if u.surveys.with_statuses([Survey::STATUS_STARTED, Survey::STATUS_FINISHED]).exists?
        u.run_any_survey = true
        u.save!
        u.save
Jobs::EmailReminderJob.run
Jobs::EmailReminderJob
